--- vcg/space/index/kdtree/kdtree.h	2014-05-20 20:23:34.541133951 +0200
+++ vcg/space/index/kdtree/kdtree.h	2014-05-20 20:31:32.215502595 +0200
@@ -54,20 +54,20 @@
 
 	struct Node
 	{
-		union {
+	  union {
                         //standard node
 			struct {
 				Scalar splitValue;
 				unsigned int firstChildId:24;
 				unsigned int dim:2;
 				unsigned int leaf:1;
-			};
+		  } mynode;
                         //leaf
-			struct {
+		  struct {
 				unsigned int start;
 				unsigned short size;
-			};
-                };
+			  	} myleaf;
+	  } NodeU;
 	};
 	typedef std::vector<Node> NodeList;
 
@@ -191,34 +191,34 @@
                 if (qnode.sq < mNeighborQueue.getTopWeight())
                 {
                         //when we arrive to a lef
-                        if (node.leaf)
+                        if (node.NodeU.mynode.leaf)
                         {
                                 --count; //pop of the leaf
 
                                 //end is the index of the last element of the leaf in mPoints
-                                unsigned int end = node.start+node.size;
+                                unsigned int end = node.NodeU.myleaf.start+node.NodeU.myleaf.size;
                                 //adding the element of the leaf to the heap
-                                for (unsigned int i=node.start ; i<end ; ++i)
+                                for (unsigned int i=node.NodeU.myleaf.start ; i<end ; ++i)
                                                 mNeighborQueue.insert(i, vcg::SquaredNorm(queryPoint - mPoints[i]));
                         }
                         //otherwise, if we're not on a leaf
                         else
                         {   
                                 // the new offset is the distance between the searched point and the actual split coordinate
-                                float new_off = queryPoint[node.dim] - node.splitValue;
+                                float new_off = queryPoint[node.NodeU.mynode.dim] - node.NodeU.mynode.splitValue;
 
                                 //left sub-tree
                                 if (new_off < 0.)
                                 {
-                                                mNodeStack[count].nodeId  = node.firstChildId;
+                                                mNodeStack[count].nodeId  = node.NodeU.mynode.firstChildId;
                                                 //in the father's nodeId we save the index of the other sub-tree (for backtracking)
-                                                qnode.nodeId = node.firstChildId+1;
+                                                qnode.nodeId = node.NodeU.mynode.firstChildId+1;
                                 }
                                 //right sub-tree (same as above)
                                 else
                                 {
-                                                mNodeStack[count].nodeId  = node.firstChildId+1;
-                                                qnode.nodeId = node.firstChildId;
+                                                mNodeStack[count].nodeId  = node.NodeU.mynode.firstChildId+1;
+                                                qnode.nodeId = node.NodeU.mynode.firstChildId;
                                 }
                                 //distance is inherited from the father (while descending the tree it's equal to 0)
                                 mNodeStack[count].sq = qnode.sq;
